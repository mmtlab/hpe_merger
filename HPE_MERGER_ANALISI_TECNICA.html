<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HPE Merger - Analisi Tecnica e Teoria</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            padding: 40px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #1a5490;
            border-bottom: 3px solid #1a5490;
            padding-bottom: 10px;
            margin-bottom: 30px;
            text-align: center;
            font-size: 2.5em;
        }
        h2 {
            color: #2c5aa0;
            margin-top: 30px;
            margin-bottom: 15px;
            border-left: 5px solid #2c5aa0;
            padding-left: 15px;
            font-size: 1.8em;
        }
        h3 {
            color: #3d6bb3;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.3em;
        }
        p {
            margin-bottom: 12px;
            text-align: justify;
        }
        .formula {
            background-color: #f0f4f8;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #2c5aa0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        .code-block {
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            padding: 15px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .warning {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
        }
        .info {
            background-color: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 15px 0;
        }
        .success {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        table th {
            background-color: #1a5490;
            color: white;
            padding: 12px;
            text-align: left;
        }
        table td {
            border-bottom: 1px solid #ddd;
            padding: 10px;
        }
        table tr:hover {
            background-color: #f5f5f5;
        }
        .section {
            page-break-inside: avoid;
        }
        .diagram {
            background-color: #f0f4f8;
            padding: 20px;
            margin: 15px 0;
            border-radius: 5px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        li {
            margin-bottom: 8px;
        }
        .page-break {
            page-break-after: always;
        }
        .toc {
            background-color: #f0f4f8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .toc a {
            color: #1a5490;
            text-decoration: none;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        .timestamp-info {
            background-color: #e7f3ff;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #2196F3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” HPE MERGER PLUGIN</h1>
        <h2 style="text-align: center; border: none; padding: 0; color: #666; margin-bottom: 30px;">Analisi Tecnica, Teoria e Spiegazione del Codice</h2>

        <div class="toc section">
            <h3>ğŸ“‹ Indice dei Contenuti</h3>
            <ol>
                <li><a href="#overview">Panoramica del Progetto</a></li>
                <li><a href="#architecture">Architettura del Sistema</a></li>
                <li><a href="#dataflow">Flusso dei Dati</a></li>
                <li><a href="#theory">Teoria Matematica Utilizzata</a></li>
                <li><a href="#load_data">Metodo load_data()</a></li>
                <li><a href="#process">Metodo process()</a></li>
                <li><a href="#fixes">Correzioni e Bug Fix</a></li>
                <li><a href="#conclusions">Conclusioni</a></li>
            </ol>
        </div>

        <div class="page-break"></div>

        <div class="section" id="overview">
            <h2>1. ğŸ“Š Panoramica del Progetto</h2>
            
            <h3>Scopo del Plugin HPE Merger</h3>
            <p>
                HPE Merger Ã¨ un plugin filter MADS (Multi-Agent Distributed System) scritto in C++ che implementa 
                un sistema avanzato di <strong>fusione di dati di scheletri umani 3D</strong> provenienti da 
                <strong>multiple fotocamere</strong>.
            </p>

            <h3>Cosa fa il Plugin?</h3>
            <ul>
                <li><strong>Riceve</strong> dati di joint (giunti) 3D da multiple fotocamere simultaneamente</li>
                <li><strong>Fonde</strong> questi dati utilizzando tecniche statistiche avanzate (Kalman-like filtering)</li>
                <li><strong>Computa</strong> velocitÃ  e covarianze per predizioni future</li>
                <li><strong>Pesa</strong> i dati in base alla loro affidabilitÃ  e al tempo trascorso</li>
                <li><strong>Emette</strong> un output JSON con i dati fusi e validati</li>
            </ul>

            <h3>Applicazioni</h3>
            <p>
                Questo tipo di sistema Ã¨ utilizzato in:
            </p>
            <ul>
                <li>Motion Capture per produzioni video/cinematografiche</li>
                <li>Analisi del movimento negli sport</li>
                <li>Riabilitazione medica e fisioterapia</li>
                <li>Ricerca biomeccanica</li>
                <li>Videogiochi con tracking di movimento realistico</li>
            </ul>
        </div>

        <div class="page-break"></div>

        <div class="section" id="architecture">
            <h2>2. ğŸ—ï¸ Architettura del Sistema</h2>

            <h3>Struttura della Classe HpemergerPlugin</h3>
            <p>
                La classe eredita da <code>Filter&lt;json, json&gt;</code> e implementa tre metodi principali:
            </p>

            <div class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         HpemergerPlugin                     â”‚
â”‚  (Filter&lt;json, json&gt;)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Metodi Pubblici:                            â”‚
â”‚ â€¢ load_data()  â†’ Riceve i dati              â”‚
â”‚ â€¢ process()    â†’ Elabora e fonde            â”‚
â”‚ â€¢ set_params() â†’ Configura i parametri     â”‚
â”‚ â€¢ get_camera_index() â†’ Gestisce le camere  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Dati Privati:                               â”‚
â”‚ â€¢ _positions[j][c]     â†’ coordinate 3D     â”‚
â”‚ â€¢ _covariances[j][c]   â†’ matrici 3x3       â”‚
â”‚ â€¢ _times[j][c]         â†’ timestamp         â”‚
â”‚ â€¢ _velocities[j]       â†’ velocitÃ  3D       â”‚
â”‚ â€¢ _merged_positions[j] â†’ coordinate fuse   â”‚
â”‚ â€¢ _merged_times[j]     â†’ timestamp fuso    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>

            <h3>Notazione Utilizzata</h3>
            <table>
                <tr>
                    <th>Simbolo</th>
                    <th>Significato</th>
                    <th>Esempio</th>
                </tr>
                <tr>
                    <td>[j]</td>
                    <td>j-esimo joint (giunto)</td>
                    <td>_velocities[0] = ginocchio destro</td>
                </tr>
                <tr>
                    <td>[c]</td>
                    <td>c-esima fotocamera</td>
                    <td>_positions[5][2] = giunto 5, camera 2</td>
                </tr>
                <tr>
                    <td>18 joint</td>
                    <td>Scheletro umano</td>
                    <td>NOS_, NEC_, SHOR, ELBR, WRIR, SHOL, ELBL, WRIL, HIPR, KNER, ANKR, HIPL, KNEL, ANKL, EYER, EYEL, EARR, EARL</td>
                </tr>
            </table>
        </div>

        <div class="page-break"></div>

        <div class="section" id="dataflow">
            <h2>3. ğŸ“ˆ Flusso dei Dati</h2>

            <div class="diagram">
Input JSON        load_data()      Storage Interno      process()      Output Fuso
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ {           â”‚       â–¼         â”‚ _positions[j][c] â”‚        â–¼      â”‚ {           â”‚
â”‚  "ts": xxx, â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ _covariances...  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ "typ":"FSD" â”‚
â”‚  "crd": [...â”‚â”€â”€â”€â”¤ Valida  â”‚â”€â”€â”€â”‚ _times[j][c]     â”‚â”€â”€â”€â”¤ Fonde e â”‚â”€â”‚ "crd":[...] â”‚
â”‚  "unc": [...â”‚   â”‚ e Mappa â”‚   â”‚ _velocities...   â”‚   â”‚ Calcola â”‚â”€â”‚ "unc":[...] â”‚
â”‚ }           â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ _merged_*        â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ }           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          Multi-Camera Storage              Fusion & Prediction
            </div>

            <h3>Ciclo di Elaborazione per un Dato</h3>
            <ol>
                <li><strong>load_data()</strong> riceve JSON da una camera
                    <ul>
                        <li>Valida la presenza del timestamp ("ts")</li>
                        <li>Assegna/recupera l'indice della camera</li>
                        <li>Estrae coordinata e covarianza di ogni joint</li>
                        <li>Memorizza i dati negli array privati</li>
                    </ul>
                </li>
                <li><strong>process()</strong> fonde i dati accumulati
                    <ul>
                        <li>Calcola i pesi temporali per ogni dato</li>
                        <li>Predice posizioni basate su velocitÃ  precedenti</li>
                        <li>Fonde i dati con tecnica di media pesata</li>
                        <li>Calcola velocitÃ  e covarianze per l'iterazione successiva</li>
                        <li>Genera output JSON</li>
                    </ul>
                </li>
            </ol>
        </div>

        <div class="page-break"></div>

        <div class="section" id="theory">
            <h2>4. ğŸ”¬ Teoria Matematica Utilizzata</h2>

            <h3>4.1 Filtering Bayesiano e Kalman-like Filtering</h3>
            <p>
                Il sistema utilizza principi di <strong>filtering bayesiano</strong> per combinare misurazioni 
                incerte da fonti multiple. L'idea chiave Ã¨ rappresentare ogni misura come una distribuzione di probabilitÃ  
                gaussiana caratterizzata da media (posizione) e covarianza (incertezza).
            </p>

            <h3>4.2 Ponderazione Temporale Gaussiana</h3>
            <p>
                Uno dei pilastri del sistema Ã¨ la <strong>ponderazione temporale</strong>. Dati piÃ¹ recenti sono 
                considerati piÃ¹ affidabili di dati vecchi. Il peso Ã¨ calcolato come una gaussiana nel tempo:
            </p>

            <div class="formula">
w(t) = exp( -[(Î”t)Â² / Ï„Â²] )

Dove:
  â€¢ w(t) = peso temporale (0 a 1)
  â€¢ Î”t = differenza di tempo in nanosecondi
  â€¢ Ï„ = costante di tempo (default: 500 ms = 500.000.000 ns)
  â€¢ exp() = funzione esponenziale
            </div>

            <div class="info">
                <strong>Cosa significa?</strong><br>
                â€¢ A Î”t=0 (dato appena ricevuto): w=1 (peso massimo)<br>
                â€¢ A Î”t=Ï„ (500 ms): wâ‰ˆ0.368 (peso ridotto al 37%)<br>
                â€¢ A Î”t=2Ï„ (1 sec): wâ‰ˆ0.135 (peso molto basso)<br>
                â€¢ A Î”t=3Ï„ (1.5 sec): wâ‰ˆ0.050 (praticamente ignorato)
            </div>

            <h3>4.3 Fusione Multisensore con Covarianze</h3>
            <p>
                Quando si hanno misure da N fotocamere, il sistema le fonde usando la tecnica della <strong>fusione pesata delle covarianze</strong>:
            </p>

            <div class="formula">
Covarianza Pesata Inversa:
  Î£_weighted = (Î£_camera Ã— w)^(-1)

Fusione di Posizioni:
  p_fuso = [Î£ Î£_weighted[i] Ã— p[i]] Ã— [Î£ Î£_weighted[i]]^(-1)

Dove:
  â€¢ Î£ = matrice di covarianza 3Ã—3
  â€¢ w = peso temporale
  â€¢ p = vettore di posizione 3D
  â€¢ ^(-1) = inversione di matrice
            </div>

            <div class="warning">
                <strong>Importante:</strong> Le matrici di covarianza sono <strong>inverse-weighted</strong>. 
                Questo significa che covarianze piccole (misure affidabili) hanno pesi grandi, 
                e covarianze grandi (misure incerte) hanno pesi piccoli.
            </div>

            <h3>4.4 Predizione Basata su VelocitÃ </h3>
            <p>
                Per migliorare le predizioni, il sistema traccia le <strong>velocitÃ </strong> di ogni giunto 
                e le utilizza per predire la posizione futura:
            </p>

            <div class="formula">
Predizione di Posizione:
  p_pred(t) = p_prev(t-Î”t) + v Ã— Î”t

Calcolo della VelocitÃ  (all'iterazione precedente):
  v = [p_fuso(t) - p_prev(t-Î”t)] / Î”t

Propagazione della Covarianza:
  Î£_pred = Î£_prev + (Î”t)Â² Ã— Î£_velocitÃ 

Dove:
  â€¢ Î”t = intervallo di tempo
  â€¢ v = vettore velocitÃ  3D
  â€¢ Î£_velocitÃ  = covarianza della velocitÃ 
            </div>

            <h3>4.5 Inversione di Matrice Singolare</h3>
            <p>
                Una covarianza singolare (determinante = 0) indica dati non affidabili. 
                Il codice gestisce questo controllando il determinante prima di invertire:
            </p>

            <div class="code-block">
if (_merged_covariances[i].determinant() != 0) {
    predicted_covariances[i] = (...).inverse();
} else {
    predicted_covariances[i] = Eigen::Matrix3d::Zero();
}
            </div>
        </div>

        <div class="page-break"></div>

        <div class="section" id="load_data">
            <h2>5. ğŸ“¥ Analisi Dettagliata: Metodo load_data()</h2>

            <h3>Signature</h3>
            <div class="code-block">
return_type load_data(json const &input, string topic = "") override
            </div>

            <h3>Passaggi Eseguiti</h3>
            <ol>
                <li><strong>Validazione Timestamp</strong>
                    <ul>
                        <li>Controlla se il campo "ts" esiste nel JSON</li>
                        <li>Se non esiste, ritorna errore</li>
                        <li>Type: uint64_t (unsigned, per supportare nanosecondi grandi)</li>
                    </ul>
                </li>

                <li><strong>Gestione Fotocamere</strong>
                    <ul>
                        <li>Chiama get_camera_index(hostname)</li>
                        <li>Se camera nuova: assegna indice, ridimensiona array</li>
                        <li>Se camera conosciuta: ritorna indice esistente</li>
                    </ul>
                </li>

                <li><strong>Estrazione Dati per ogni Joint</strong>
                    <ul>
                        <li>Itera su tutti i campi del JSON input</li>
                        <li>Cerca "crd" (coordinate) e "unc" (uncertainties)</li>
                        <li>Converte stringa-label in indice numerico via map</li>
                    </ul>
                </li>

                <li><strong>Memorizzazione Posizioni</strong>
                    <div class="code-block">
_positions[joint_index][camera_index] = Eigen::Vector3d(
    data["crd"][0], data["crd"][1], data["crd"][2]
);
                    </div>
                </li>

                <li><strong>Costruzione Matrice Covarianza</strong>
                    <p>Il JSON fornisce 6 elementi (matrice simmetrica 3Ã—3):</p>
                    <div class="formula">
Input: [Ïƒxx, Ïƒyy, Ïƒzz, Ïƒxy, Ïƒxz, Ïƒyz]

Matrice:
| Ïƒxx  Ïƒxy  Ïƒxz |
| Ïƒxy  Ïƒyy  Ïƒyz |
| Ïƒxz  Ïƒyz  Ïƒzz |
                    </div>
                </li>

                <li><strong>Memorizzazione Timestamp</strong>
                    <div class="code-block">
_times[joint_index][camera_index] = timestamp;
                    </div>
                </li>
            </ol>

            <h3>Correzioni Applicate</h3>
            <div class="success">
                <strong>âœ“ Fix 1: Tipo uint64_t per Timestamp</strong><br>
                Il timestamp era inizialmente <code>long</code> (type signed a 32-64 bit).
                Valori grandi in nanosecondi causavano <strong>overflow</strong> e numeri negativi.
                <br><br>
                Soluzione: Cambiato a <code>uint64_t</code> che supporta fino a 18 quintilioni di nanosecondi 
                (circa 584 anni).
            </div>

            <div class="timestamp-info">
                <strong>ğŸ“Œ Informazioni Timestamp</strong><br>
                â€¢ 1 ms = 1.000.000 ns<br>
                â€¢ 1 sec = 1.000.000.000 ns<br>
                â€¢ uint64_t max â‰ˆ 18 Ã— 10^18 ns â‰ˆ 584 anni<br>
                â€¢ Questo supporta tranquillamente qualsiasi sistema in tempo reale
            </div>
        </div>

        <div class="page-break"></div>

        <div class="section" id="process">
            <h2>6. âš™ï¸ Analisi Dettagliata: Metodo process()</h2>

            <h3>Panoramica Generale</h3>
            <p>
                Il metodo process() Ã¨ il cuore della fusione. Riceve i dati accumulati da load_data() 
                e produce un output JSON fuso e predetto.
            </p>

            <h3>Fase 1: Calcolo del Timestamp Corrente</h3>
            <div class="code-block">
auto now = std::chrono::system_clock::now();
int64_t timestamp = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;
    (now.time_since_epoch()).count();
            </div>
            <p>
                Ottiene il timestamp di sistema corrente in nanosecondi dall'epoch (1 gennaio 1970 UTC).
            </p>

            <h3>Fase 2: Calcolo Pesi Temporali e Predizioni</h3>
            <p>Per ogni giunto j, calcola:</p>

            <div class="formula">
1. Differenza temporale:
   merged_time_diff = timestamp_corrente - _merged_times[j]

2. Peso gaussiano:
   w[j] = exp( -[(merged_time_diff)Â² / Ï„Â²] )

3. Predizione posizione:
   p_pred[j] = p_prev[j] + v[j] Ã— merged_time_diff

4. Propagazione covarianza:
   Î£_pred[j] = Î£_prev[j] + (merged_time_diff)Â² Ã— Î£_vel[j]

5. Covarianza pesata:
   Î£_pred_pesata[j] = (Î£_pred[j] Ã— w[j])^(-1)
            </div>

            <h3>Fase 3: Calcolo Pesi per Dati di Input</h3>
            <p>Per ogni giunto j e camera c, calcola il peso temporale:</p>

            <div class="code-block">
int64_t time_diff = timestamp - _times[joint][cam];
double time_const = _params["time_weight_normalization"].get&lt;double&gt;();
weights[joint][cam] = exp( -((time_diff)*(time_diff)) / (time_const * time_const) );
            </div>

            <div class="warning">
                <strong>ğŸ”´ Bug Corretto:</strong> Originariamente mancava il quadrato al denominatore!<br>
                Sbagliato: exp(-(Î”t)Â² / Ï„)<br>
                Corretto: exp(-(Î”t)Â² / Ï„Â²)<br><br>
                Senza il quadrato al denominatore, il peso diventava praticamente zero dopo pochi millisecondi.
            </div>

            <h3>Fase 4: Calcolo Covarianze Pesate Inverse</h3>
            <div class="formula">
weighted_covariances[j][c] = (_covariances[j][c] Ã— weights[j][c])^(-1)

Questo Ã¨ il cuore della fusione bayesiana:
- Covarianze piccole (misure affidabili) â†’ pesi grandi
- Covarianze grandi (misure incerte) â†’ pesi piccoli
            </div>

            <h3>Fase 5: Fusione Posizioni e Covarianze</h3>
            <p>Per ogni giunto j:</p>

            <div class="formula">
1. Somma covarianze inverse pesate:
   Î£_merged = Î£(weighted_covariances[j][c]) + Î£_pred[j]

2. Inverte per ottenere covarianza fusa:
   Î£_fuso[j] = Î£_merged^(-1)

3. Fonde posizioni:
   p_fuso[j] = Î£_fuso[j] Ã— [Î£(weighted_covariances[j][c] Ã— p[j][c]) + Î£_pred[j] Ã— p_pred[j]]

4. Conta fotocamere utilizzate:
   _camera_used[j] = numero di camere con covarianza valida
            </div>

            <h3>Fase 6: Calcolo VelocitÃ  per Prossima Iterazione</h3>
            <div class="formula">
1. Intervallo di tempo:
   dt = timestamp - _merged_times[j]

2. VelocitÃ  (differenza di posizioni divisa per tempo):
   v[j] = (p_fuso[j] - p_prev[j]) / dt

3. Covarianza della velocitÃ :
   Î£_vel[j] = (1/dtÂ²) Ã— (Î£_fuso[j] + Î£_prev[j])

4. Aggiorna timestamp:
   _merged_times[j] = timestamp
            </div>

            <h3>Fase 7: Generazione Output JSON</h3>
            <div class="code-block">
out["ts"] = timestamp;
out["typ"] = "FSD";  // Fusion Skeleton Data

for (size_t joint = 0; joint < _merged_positions.size(); ++joint) {
    string joint_name = keypoints_map_int2string[joint];
    out[joint_name]["ncm"] = _camera_used[joint];     // num cameras
    out[joint_name]["crd"] = { px, py, pz };         // coordinates
    out[joint_name]["unc"] = { Ïƒxx, Ïƒyy, Ïƒzz, Ïƒxy, Ïƒxz, Ïƒyz };  // covariance
}
            </div>

            <div class="success">
                <strong>âœ“ Fix 2: Segno Negativo nell'Esponente</strong><br>
                Originariamente: exp(+(Î”t)Â² / Ï„Â²) â†’ overflow a inf<br>
                Corretto: exp(-(Î”t)Â² / Ï„Â²) â†’ decadimento corretto<br><br>
                Senza il segno negativo, il peso aumentava esponenzialmente con il tempo, 
                causando infinito overflow.
            </div>

            <div class="success">
                <strong>âœ“ Fix 3: Quadrato al Denominatore nella Costante di Tempo</strong><br>
                Originariamente: exp(-(Î”t)Â² / Ï„) â†’ peso zero dopo millisecondi<br>
                Corretto: exp(-(Î”t)Â² / Ï„Â²) â†’ decadimento realistico<br><br>
                Con il quadrato al denominatore, il decadimento Ã¨ gaussiano corretto:
                a Ï„ il peso Ã¨ 0.368, non 0.
            </div>
        </div>

        <div class="page-break"></div>

        <div class="section" id="fixes">
            <h2>7. ğŸ”§ Correzioni e Bug Fix Applicati</h2>

            <h3>Bug 1: Overflow Timestamp - CRITICO</h3>
            <table>
                <tr>
                    <th>Aspetto</th>
                    <th>Problema</th>
                    <th>Soluzione</th>
                    <th>Impatto</th>
                </tr>
                <tr>
                    <td>Tipo Dati</td>
                    <td>long (signed) causa overflow</td>
                    <td>uint64_t (unsigned)</td>
                    <td>CRITICO</td>
                </tr>
                <tr>
                    <td>Valori Interessati</td>
                    <td>_times, _merged_times, timestamp</td>
                    <td>Tutti cambati a uint64_t</td>
                    <td>3 file cambiamenti</td>
                </tr>
                <tr>
                    <td>Esempio</td>
                    <td>timestamp 2,916,594,700 â†’ -1,378,372,572</td>
                    <td>Rimane 2,916,594,700</td>
                    <td>Dati corretti</td>
                </tr>
            </table>

            <h3>Bug 2: Infinito nelle Equazioni di Peso - CRITICO</h3>
            <table>
                <tr>
                    <th>Riga</th>
                    <th>Errore</th>
                    <th>Correzione</th>
                    <th>Risultato</th>
                </tr>
                <tr>
                    <td>120, 148</td>
                    <td>exp(+(Î”t)Â²/Ï„Â²)</td>
                    <td>exp(-(Î”t)Â²/Ï„Â²)</td>
                    <td>Peso âˆˆ [0,1]</td>
                </tr>
                <tr>
                    <td>Effetto</td>
                    <td>Peso â†’ +âˆ</td>
                    <td>Peso â†’ 0-1</td>
                    <td>Output finito</td>
                </tr>
            </table>

            <h3>Bug 3: Denominatore Senza Quadrato - IMPORTANTE</h3>
            <table>
                <tr>
                    <th>Parametro</th>
                    <th>Formula Sbagliata</th>
                    <th>Formula Corretta</th>
                    <th>A 31ms</th>
                </tr>
                <tr>
                    <td>Peso</td>
                    <td>exp(-(Î”t)Â²/Ï„)</td>
                    <td>exp(-(Î”t)Â²/Ï„Â²)</td>
                    <td>â‰ˆ0.996</td>
                </tr>
                <tr>
                    <td>Effetto</td>
                    <td>Peso â†’ 0 molto veloce</td>
                    <td>Decadimento gaussiano corretto</td>
                    <td>Fusion corretta</td>
                </tr>
            </table>

            <h3>Confronto Prima vs Dopo Correzioni</h3>
            <div class="diagram">
PRIMA (Errato):                    DOPO (Corretto):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
timestamp = -1378372572 ns âœ—      timestamp = 590763424 ns âœ“
weight = âˆ (overflow) âœ—           weight âˆˆ [0,1] âœ“
output = NaN âœ—                    output = valido âœ“
posizioni fuse = invalide âœ—       posizioni fuse = corrette âœ“
            </div>
        </div>

        <div class="page-break"></div>

        <div class="section" id="conclusions">
            <h2>8. ğŸ“‹ Conclusioni e Raccomandazioni</h2>

            <h3>Punti Chiave del Sistema</h3>
            <ol>
                <li><strong>Architettura Multi-Camera</strong>
                    <ul>
                        <li>Supporta N fotocamere simultaneamente</li>
                        <li>Gestisce telecamere che si aggiungono/tolgono dinamicamente</li>
                    </ul>
                </li>

                <li><strong>Fusione Bayesiana Robusta</strong>
                    <ul>
                        <li>Utilizza matrici di covarianza per rappresentare incertezze</li>
                        <li>Pesa i dati in base a affidabilitÃ  (covarianza) e recency (tempo)</li>
                    </ul>
                </li>

                <li><strong>Predizione Kalman-like</strong>
                    <ul>
                        <li>Traccia velocitÃ  e propagazione incertezze</li>
                        <li>Predice posizioni per compensare latenza</li>
                    </ul>
                </li>

                <li><strong>Gestione Temporale Rigorosa</strong>
                    <ul>
                        <li>uint64_t nanosecond timestamps</li>
                        <li>Gaussiano time-weighting per decadimento graduale</li>
                    </ul>
                </li>
            </ol>

            <h3>Raccomandazioni per Miglioramenti Futuri</h3>

            <div class="info">
                <strong>1. Utilizzo di Generatore Random Moderno</strong><br>
                Sostituire rand() con &lt;random&gt; C++11 per qualitÃ  migliore:
                <div class="code-block">
#include &lt;random&gt;
std::mt19937 gen(seed);
std::uniform_int_distribution&lt;&gt; dis(1000000, 30000000);
int64_t delay = dis(gen);  // 1-30ms
                </div>
            </div>

            <div class="info">
                <strong>2. ConfigurabilitÃ  dei Parametri</strong><br>
                Considerare di rendere configurabili:
                <ul>
                    <li>time_weight_normalization (attualmente 500ms fisso)</li>
                    <li>Soglie di validitÃ  covarianza</li>
                    <li>Numero minimo di camere richieste</li>
                </ul>
            </div>

            <div class="info">
                <strong>3. Logging e Diagnostica</strong><br>
                Aggiungere:
                <ul>
                    <li>Contatori di qualitÃ  (quanti dati scartati)</li>
                    <li>Metriche di fusion (residui, incertezze medie)</li>
                    <li>Alert per singolaritÃ  di matrici</li>
                </ul>
            </div>

            <div class="warning">
                <strong>4. Gestione Errori Edge Cases</strong><br>
                Gestire meglio:
                <ul>
                    <li>Assenza di dati per periodo lungo</li>
                    <li>Desincronizzazione clock tra camere</li>
                    <li>Arrivo dati fuori ordine (retroattivi)</li>
                </ul>
            </div>

            <h3>Validazione del Codice</h3>
            <div class="success">
                <strong>âœ“ Type Safety</strong><br>
                Il codice Ã¨ type-safe con Eigen::Vector3d e Eigen::Matrix3d
            </div>

            <div class="success">
                <strong>âœ“ Memory Safety</strong><br>
                Utilizzo di std::vector e Eigen - no raw pointers
            </div>

            <div class="warning">
                <strong>âš  Thread Safety</strong><br>
                NON Ã¨ thread-safe. load_data() e process() devono essere sincronizzati
            </div>

            <div class="warning">
                <strong>âš  Performance</strong><br>
                Potrebbe beneficiare di parallelizzazione (OpenMP) per large N camere
            </div>

            <h3>Riferimenti Teorici</h3>
            <ul>
                <li><strong>Kalman Filter:</strong> R. Kalman, "A New Approach to Linear Filtering and Prediction Problems", 1960</li>
                <li><strong>Multi-Sensor Fusion:</strong> Bar-Shalom & Li, "Estimation and Tracking: Principles, Techniques, and Software", 1993</li>
                <li><strong>Gaussian Processes:</strong> Rasmussen & Williams, "Gaussian Processes for Machine Learning", 2006</li>
                <li><strong>Eigen Library:</strong> http://eigen.tuxfamily.org (linear algebra in C++)</li>
            </ul>
        </div>

        <div class="page-break"></div>

        <div class="section">
            <h2>Riepilogo dei Numeri</h2>
            <table>
                <tr>
                    <th>Metrica</th>
                    <th>Valore</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td>Joint tracciati</td>
                    <td>18</td>
                    <td>Scheletro umano completo</td>
                </tr>
                <tr>
                    <td>Camere supportate</td>
                    <td>N (dinamico)</td>
                    <td>Aggiungibili/rimovibili runtime</td>
                </tr>
                <tr>
                    <td>Dimensione matrice covarianza</td>
                    <td>3Ã—3</td>
                    <td>Per ogni joint e camera</td>
                </tr>
                <tr>
                    <td>Linee di codice plugin</td>
                    <td>416</td>
                    <td>Implementazione completa</td>
                </tr>
                <tr>
                    <td>Timestamp resolution</td>
                    <td>1 nanosecondo</td>
                    <td>uint64_t in ns da epoch</td>
                </tr>
                <tr>
                    <td>Tempo di decay peso</td>
                    <td>500 ms</td>
                    <td>Costante (configurabile)</td>
                </tr>
            </table>

            <h2 style="text-align: center; margin-top: 50px; color: #1a5490;">ğŸ¯ Fine Analisi</h2>
            <p style="text-align: center; color: #999;">Documento generato: 18 Dicembre 2025</p>
        </div>
    </div>
</body>
</html>